1. 实现sys_task_info系统调用
2.  <br>
    1. (1)使用非法的地址<br>
       (2)使用非法的指令<br>
       (3)使用非法的寄存器<br>
    2. (1)内核栈指针,用户态Trap到内核态后从内核态返回到用户态, 应用程序第一次执行<br>
       (2)sstatus, sepc, sscratch<br>
       sstatus中的SPP 等字段给出 Trap 发生之前 CPU 处在哪个特权级（S/U）等信息, 通过将SPP设置为User, 当Trap结束后,会返回到用户态<br>
       sepc指向Trap返回后会执行的下一条指令的地址<br>
       sscratch 指向内核栈,通过和sp交换保存用户栈指针,当Trap结束后,恢复用户栈指针<br>
    3. x2指向栈顶,是栈指针,用户栈的栈指针保存在 sscratch 中, x4的值不会变化, 应用程序不使用x4
    4. 交换 sscratch 和 sp
    5. sret, 通过设置SPP为User, 表示在Trap前,位于用户态
    6. 交换 sscratch 和 sp 
    7. ecall
<br>

1. 在完成本次实验的过程（含此前学习的过程）中，我曾分别与 以下各位 就（与本次实验相关的）以下方面做过交流，还在代码中对应的位置以注释形式记录了具体的交流对象及内容：
2. 此外，我也参考了 以下资料 ，还在代码中对应的位置以注释形式记录了具体的参考来源及内容：
3. 我独立完成了本次实验除以上方面之外的所有工作，包括代码与文档。 我清楚地知道，从以上方面获得的信息在一定程度上降低了实验难度，可能会影响起评分。
4.  我从未使用过他人的代码，不管是原封不动地复制，还是经过了某些等价转换。 我未曾也不会向他人（含此后各届同学）复制或公开我的实验代码，我有义务妥善保管好它们。 我提交至本实验的评测系统的代码，均无意于破坏或妨碍任何计算机系统的正常运转。 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的实验成绩将按“-100”分计

